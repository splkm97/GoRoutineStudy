학습 목표: GO 의 동시성
-> 메모리 공유를 통해 통신 x
but, 통신을 통해 메모리를 공유하라!

**고루틴
**채널
**select 구문
**sync패키지: WaitGroup, Mutex, Cond, ...

제너레이터(Generators)
-> 제너레이터는 반복자(Iterator)를 생성하는 함수

반복자(Iterator)
->호출될 때마다 일정 규칙상 다음값을 반환하는 함수

클로저(Closure)
->함수와 함수의 렉시컬 스코프(Lexical scope)

렉시컬 스코프(Lexical scope)
-> 중첩된 함수들 사이에서 변수가 결정되는 범위를 정의함.

고루틴 -> thread, context switching 비용이 엄청나게 적다:
물쓰듯이 써 제발! but, 가비지 컬렉션은 안됨

채널: 고루틴끼리 데이터를 주고받고, 실행 흐름을 제어한다.
for i := range ch1 {
	fmt.Println(i)
}
-> range 키워드와 함께 쓰는 채널

%%%%%%%%%%% 과제:

** 클로저의 개념 파악정리(문서화)

** "메모리 공유를 통해 통신하지 말고,
통신을 통해 메모리를 공유하라"
// 뮤텍스를 통해 통신 x 채널을 통해 메모리 공유 o
// -> sync패키지 사용 x 기본 라이브러리 사용 o
-> 의 의미를 파악, 정리하여 문서화

** select구문을 알아보고 정리하여 문서화
** Combination 제너레이터 구현
** n비트 이진 그레이 코드를 순서대로 출력하는 제너레이터 구현
** n개 원반 이동하는 하노이 탑 제너레이터 작성
** 주어진 파일에서 모든 단어를 순서대로 출력하는 제너레이터 구현

채널 동시성 제어를 위해 가장 빠르게 보낼 수 있는 데이터 형이나 그런게 있는지?? -> chan struct{}의 경우 메모리가 0이므로 가장 빠름
